# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Purpose

This is a collaborative game development project between a parent and their 8-year-old son. The goals are:

1. **Educational Experience**: Teach game development concepts in an age-appropriate way
2. **LLM Collaboration**: Demonstrate how to work with AI tools to build real projects
3. **Planning & Execution**: Show the process of going from complex idea → concrete plan → achievable tasks

## Communication Style for This Project

**When interacting:**
- Use clear, simple language that an 8-year-old can understand
- Break down complex concepts into digestible pieces
- Celebrate small wins and progress
- Make the process fun and engaging
- Ask for input and ideas from both collaborators
- Explain technical decisions in accessible terms

**When explaining code:**
- Use analogies and real-world comparisons
- Show visual or interactive examples when possible
- Explain WHY things work, not just WHAT they do
- Encourage questions and experimentation

## Project Workflow

### From Idea to Implementation

This project emphasizes the software development lifecycle:

1. **Idea Phase**: Capture the creative vision
   - What kind of game do we want to make?
   - What will make it fun?
   - What do players do?

2. **Planning Phase**: Break down into concrete steps
   - What are the main features?
   - What do we build first?
   - What can we add later?

3. **Task Phase**: Create achievable, small tasks
   - Each task should feel accomplishable
   - Tasks should build on each other
   - Success should be visible

4. **Implementation**: Write the code together
   - Explain what you're doing as you go
   - Test frequently
   - Show progress often

### Making Changes

- **Always explain the plan before coding**: Help both collaborators understand what will happen
- **Use the TodoWrite tool**: Make the task list visible so everyone can see progress
- **Test immediately**: Show results right away so the impact is clear
- **Iterate based on feedback**: This is a learning process, not a race

## Technical Considerations

### Technology Choices

When suggesting technology, prioritize:
- **Immediate feedback loops**: Choose tools that show results quickly
- **Visual output**: Games should be visible and interactive
- **Simple setup**: Minimize installation and configuration friction
- **Age-appropriate complexity**: Start simple, add complexity gradually

### Recommended Stack (when needed)

- **Web-based games**: HTML5 Canvas, JavaScript - runs in browser, no install
- **Python games**: Pygame - simple, visual, great for learning
- **Scratch-style**: Consider visual programming concepts for early stages

### Code Structure

- **Start with one file**: Don't over-architect early
- **Extract when needed**: Refactor only when the current approach becomes limiting
- **Comment generously**: Explain the "why" behind game logic
- **Use descriptive names**: Variable and function names should be self-documenting

## Game Development Patterns

### Start Simple, Then Enhance

A good progression for game development with young learners:

1. **Static screen**: Just draw something
2. **Add movement**: Make one thing move
3. **Add control**: Respond to keyboard/mouse
4. **Add objective**: Give the player something to do
5. **Add challenge**: Make it interesting
6. **Polish**: Make it feel good to play

### Show Progress Frequently

- Commit after each visible improvement
- Use conventional commits but keep descriptions simple
- Each commit should represent a working state
- Test changes before committing

## Educational Moments

When opportunities arise, teach:

- **Coordinates and math**: Game positioning teaches real math concepts
- **Logic and conditionals**: Game rules are if/then statements
- **Variables and state**: Scores and lives demonstrate data management
- **Functions and reuse**: Repeated game actions become functions
- **Debugging**: Problems are puzzles to solve together

## Collaboration Tips

- **Involve the young developer**: Ask "What should happen next?" frequently
- **Offer choices**: Present 2-3 options rather than just implementing
- **Encourage experimentation**: "What if we changed this number?"
- **Make it playable early**: A simple, playable game beats a complex, broken one
- **Balance teaching and doing**: Sometimes explain, sometimes just show

## Project Evolution

As the project grows:
- Update this file with learnings
- Document patterns that work well
- Note what the young developer enjoyed most
- Track skill progression
- Celebrate milestones

---

**Remember**: The code quality matters less than the learning experience and sense of accomplishment. Build something that works, that's fun, and that teaches. Optimize for joy and understanding.
